# MySQL使用过程笔记

- 在 MySQL 中，可以使用 `INSERT ... ON DUPLICATE KEY UPDATE` 语句来实现根据指定条件修改或新增字段

- 使用`SQL_CALC_FOUND_ROWS `让 MySQL 在计算结果集时考虑完整的数据行数，而不仅仅是 LIMIT 子句指定的行数。这样就可以在不重新执行查询的情况下，通过 FOUND_ROWS() 获取完整结果集的行数。

  - SQL_CALC_FOUND_ROWS:

  当你使用 LIMIT 子句限制查询结果时，SQL_CALC_FOUND_ROWS 指示 MySQL 在应用 LIMIT 之前计算结果集的总行数。
  这样，即使你只获取了部分结果（例如分页查询），你仍然可以知道整个结果集有多少行。

  - FOUND_ROWS():

  这个函数返回最近一次使用 SQL_CALC_FOUND_ROWS 的查询所产生的总行数。
  它不需要重新执行查询，因此提高了性能。
  举个例子：

  ```javascript
  const whereClause = "WHERE user_id = ? AND notes IS NOT NULL AND is_delete = 0 ";
  const dataQuery = `
    SELECT SQL_CALC_FOUND_ROWS word_id, subject_id, notes 
    FROM fllp_user_words 
    ${whereClause} 
    LIMIT ?, ?;
    SELECT FOUND_ROWS() AS total_count;
  `;
  
  connection.query(dataQuery, [user_id, offset, limit], (err, results) => {
    if (err) ...// 处理错误
    const data = results[0]; // 获取查询的数据部分
    const totalCount = results[1][0].total_count; // 获取总行数
  
    const response = {
  	total_count: totalCount,
  	data: data
    };
  });
  ```

  在这个例子中：

  `SQL_CALC_FOUND_ROWS`告诉 MySQL 计算完整结果集的行数，即使应用了 LIMIT。
  `SELECT FOUND_ROWS()` 作为第二个查询，返回第一个查询的完整结果集行数。
  `results[0]` 包含查询的数据部分，`results[1][0].total_count`包含总行数。
  这样做的好处是你可以在一次查询中获取到总记录数和实际的数据，而无需分别执行两个查询，从而提高性能并简化代码。
  
  
<<<<<<< HEAD

## 预加载

MySQL 数据库本身并没有一个专门的“预加载”机制，但可以通过一些技术和策略来实现类似的效果，以提高查询性能和减少延迟。以下是一些常见的方法：

1. **查询缓存（Query Cache）**

虽然 MySQL 8.0 及以上版本已经移除了查询缓存功能，但在 MySQL 5.7 及之前的版本中，查询缓存可以存储 SELECT 语句的结果，以便在相同的查询再次执行时直接返回缓存结果，而不需要重新执行查询。

2. **InnoDB 缓存池（InnoDB Buffer Pool）**

InnoDB 存储引擎有一个缓存池，用于缓存表数据和索引数据。当数据被频繁访问时，它们会被缓存到内存中，从而加快后续的查询速度。可以通过调整 `innodb_buffer_pool_size` 参数来增加缓存池的大小。

3. **预热缓存**

可以通过在应用程序启动时或在低峰时段执行一些常见的查询来预热缓存。这样，当实际用户请求到来时，数据已经在内存中，可以快速返回结果。

4. **分区表（Partitioning）**

将大表分成多个小表（分区），可以提高查询性能。每个分区可以独立地进行缓存和优化。

5. **使用内存表（Memory Tables）**

对于一些小的、读多写少的数据集，可以考虑使用 MEMORY 存储引擎。MEMORY 表的数据存储在内存中，因此查询速度非常快，但数据在服务器重启后会丢失。

6. **持久化缓冲池（InnoDB Persistent Memory Pool）**

从 MySQL 5.6 开始，InnoDB 支持持久化缓冲池，可以在重启后恢复缓存池的内容，从而减少冷启动时的性能损失。可以通过设置 `innodb_buffer_pool_load_at_startup` 和 `innodb_buffer_pool_dump_at_shutdown` 参数来启用此功能。

7. **预读取（Pre-fetching）**

在某些情况下，可以使用多线程或异步查询来预读取数据。例如，可以在用户登录时预读取用户经常访问的数据，以减少后续请求的延迟。

8. **使用缓存层（如 Redis 或 Memcached）**

虽然这不是 MySQL 本身的特性，但可以在 MySQL 之上使用缓存层来存储常用数据。当应用程序需要这些数据时，首先从缓存中读取，如果缓存中没有再从 MySQL 中读取并更新缓存。

9. **索引优化**

合理设计和使用索引可以显著提高查询性能。通过分析查询模式，可以创建适当的索引来加速数据检索。

10. **分区和分片（Sharding）**

对于非常大的数据集，可以考虑将数据分布在多个数据库实例上，每个实例处理一部分数据。这可以提高查询性能和可扩展性。



## 行锁定

行级锁定是一种数据库锁机制，它允许并发事务在同一张表上执行不同的操作，但对同一行数据的操作会被阻塞，直到锁定被释放。这种机制可以防止多个事务同时修改同一行数据，从而避免数据不一致的问题。

```sql
SELECT * FROM node_task 
WHERE `node_id` = 1 AND `app_id` = 1 AND `status` = 0 AND `exec_status` = 0 AND `deleted_at` IS NULL 
FOR UPDATE;
```

这条 SQL 语句会锁定满足条件的所有行，直到当前事务结束（提交或回滚）

**`FOR UPDATE` 锁的作用**:

- **锁定行**：当一个事务执行带有 `FOR UPDATE` 锁的查询时，它会锁定查询结果集中的所有行。其他事务在这些行上执行 `SELECT ... FOR UPDATE`、`UPDATE` 或 `DELETE` 操作时会被阻塞，直到第一个事务提交或回滚。
- **防止数据竞争**：这种锁定机制可以防止多个事务同时修改同一行数据，从而确保数据的一致性。
=======
  
  
  

### 在linux中使用myssql
1. `mysql -u root -p`
2. 输入密码123456
3. 进入mysql，`use mysql`



### mysql表引擎

### 1. InnoDB

- **支持事务**：InnoDB支持ACID事务，允许使用`BEGIN`、`COMMIT`和`ROLLBACK`。
- **行级锁**：提供行级锁，以提高并发性能，特别是在高并发的写操作中。
- **外键支持**：支持外键约束，可以维护数据完整性。
- **崩溃恢复**：在系统崩溃后，InnoDB会自动恢复未完成的事务，确保数据一致性。
- **适用场景**：适合需要高并发、数据一致性要求高的应用，如在线交易系统、内容管理系统等。

### 2. MyISAM

- **不支持事务**：所有操作都是自动提交的，无法使用事务控制。
- **表级锁**：在写入时锁定整个表，可能导致性能瓶颈，但对读取性能优化良好。
- **全文索引**：支持全文索引，适合进行复杂的文本搜索。
- **适用场景**：适合以读取为主的应用，如日志存储、数据分析等，但在高并发写入时可能表现不佳。

### 3. MEMORY

- **数据存储在内存中**：所有数据存储在内存中，提供非常快的访问速度。
- **表级锁**：不支持事务，使用表级锁。
- **适用场景**：适合需要快速访问的临时数据，如会话管理、缓存等。数据丢失风险高，因为重启后数据会消失。

### 4. ARCHIVE

- **高效存储大量数据**：专为存储历史数据而设计，支持压缩存储。
- **只支持插入和查询**：不支持更新或删除操作，适合只需记录数据的场景。
- **适用场景**：适合日志数据、审计数据存储，存储量大但读取频率低的应用。

### 5. CSV

- **以CSV格式存储数据**：将数据存储为CSV文件，易于导入和导出。
- **不支持索引**：查询性能相对较差，不支持事务。
- **适用场景**：适合简单的数据存储和交换，通常用于导入/导出数据的场景。

### 6. FEDERATED

- **分布式数据库引擎**：允许在一个MySQL服务器上访问其他MySQL服务器的数据。
- **不支持事务**：无法使用事务控制。
- **适用场景**：适合需要在多个MySQL数据库之间进行数据共享和访问的应用。

### 7. NDB (Cluster)

- **用于MySQL Cluster**：提供高可用性和可扩展性，支持分布式数据库架构。
- **支持事务**：支持ACID事务，但性能和复杂性相对较高。
- **适用场景**：适合需要高可用性和横向扩展的分布式应用，如在线游戏、社交网络等。



## 数据库三大范式：

**1.1 第一范式（1NF）无重复的列**

第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。



**1.2 第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]**

非主属性完全依赖于主关键字

> 不符合第二范式：假定选课关系表为SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)，关键字为组合关键字(学号, 课程名称)，因为存在如下决定关系：(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)
>
> 这个数据库表不满足第二范式，因为存在如下决定关系：
>
>  (课程名称) → (学分)
>
> (学号) → (姓名, 年龄)
>
> 即存在组合关键字中的字段决定非关键字的情况。



**1.3 第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]**

第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。

> 例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。



**1.4 鲍依斯-科得范式（BCNF是3NF的改进形式）**

若关系模式R是第一范式，且每个属性都不传递依赖于R的候选键。这种关系模式就是BCNF模式。即在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合鲍依斯-科得范式。

> 假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：
>
> (仓库ID, 存储物品ID) →(管理员ID, 数量)
>
> (管理员ID, 存储物品ID) → (仓库ID, 数量)
>
> 所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：
>
> (仓库ID) → (管理员ID)
>
> (管理员ID) → (仓库ID)
>
> 即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。
>>>>>>> f3a0cc6 (doc: mysql)
